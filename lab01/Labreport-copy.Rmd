---
title: "Lab1"
output:
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    highlight: tango
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  fig.height=4, fig.width=8, 
                      message=FALSE, warning=FALSE)
library(ggplot2)
theme_set(theme_bw(base_family = "serif") +
              theme(axis.title.x = element_text(angle = 0, hjust = 1),
                    axis.title.y = element_text(angle = 0, vjust = 1),
                    axis.title.y.right = element_text(angle = 0, vjust = 1)))
ddcol <- c('#15547d','#7ac636','#236f1e','#f62624','#9e1213',
           '#fb8f03','#4c9cc6','#b25800','#9565ad','#4a2a6b')
mdcol <- c('#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c',
           '#fdbf6f','#a6cee3','#ff7f00','#cab2d6','#6a3d9a')
ldcol <- c('#59abe2','#cceab2','#69d462','#fcbdbc','#ed696a',
           '#fdd5a1','#c5dfec','#ffab59','#dccce4','#966bc4')
nice_scatter <- function(dat, x, y, colour, title="", legend = "right"){
    ggplot(dat, aes_string(x=x, y = y, colour = colour, fill = colour)) +
        geom_point(shape = 21) +
        scale_fill_manual(values = ldcol) +
        scale_colour_manual(values = ddcol) +
        labs(title=title) +
        theme(legend.position = legend)
}
```

# Numeric precision in comparisons

*Check and comment the result of the code supplied. Suggest improvements*

```{r}
x1<-1/3;x2<-1/4
if (x1-x2==1/12){
    print("Subtraction is correct")
} else {
    print("Subtraction is wrong")
}
```

Since the denominators are not powers of 2, they will not be represented correctly in memory.

```{r}
x1<-1;x2<-1/2
if (x1-x2==1/2){
    print("Subtraction is correct")
} else {
    print("Subtraction is wrong")
}

```

Here, the denominator is a power of two ($\frac{1}{2}=2^{-1}$), hence the comparison is done correctly.

A better solution is to use the all_equal()-function that is built to handle the issues of numeric precision.

# Derivatives

*Implement your own derivative function using the definition of a derivative and run this on $f(x)=x$ and comment.*

```{r}
derivate <- function(x, f, eps=1e-15){ (f(x+eps) - f(x)) / eps }
fx <- function(x){x}
sapply(c(1, 1e5), derivate, f = fx)
```

The true derivative of $f(x)=x$ is $1$ for all $x$. This means that whatever x we input in the function we should get $1$ in return. This is clearly not happening above. In the first case, the value for nominator is not evaluated to $10^{-15}$ but rather $1.110223...*10^{-15}$, and in the second case, the computer is unable to consider the two numbers in the nominator as different, leading to the nominator being evaluated to $0$.

# Variance

 *Write your own function to calculate variance, apply it to a set of simulated values and suggest improvements*
 
```{r}
myvar <- function(x){
    n <- length(x)
    (sum(x*x) - (1/n) * sum(x)^2) * (1 / (n - 1))
}
set.seed(12345)
nx <- 10000
# assuming normally distributed numbers
x <-rnorm(nx, 1e8, 1)
varplot <- data.frame(Var = sapply(2:nx, function(i){ var(x[1:i]) }), 
                      MyVar = sapply(2:nx, function(i){ myvar(x[1:i]) }),
                      Num_obs = 2:nx, col = "a")
varplot$Diff <- varplot$MyVar - varplot$Var
```
 
 
```{r echo=FALSE}
ggplot(varplot, aes(x=Num_obs)) +
    geom_point(aes(y = Diff, col = "Difference",  fill = "Difference", shape = "Difference")) +
    geom_point(aes(y = Var, col = "Var()", fill = "Var()", shape = "Var()")) +
    scale_fill_manual(name="",values = ldcol) +
    scale_colour_manual(name="",values = ddcol) +
    scale_shape_manual(name="",values = c(21,21)) +
    labs(title="Difference between built-in variance function and own implementation\n by number of observations used") +
    scale_x_log10() +
    theme(legend.position = "bottom")
```
 
The variance of the vector does vary a bit over the first 100 observations but this is expected due to the underlying randomness of the data. The built-in function does however seem to converge to the actual value as more and more observations are used for the calculation. At certain points, the custom function seem to return 0, indicated by the line at $-1$ in the plot and there is clearly a pattern to this, as is there to the values returned in general. This likely has to do with suffering precision in handling the sum of squares term ($\sum(x^2)$) and the squared sum (($\Big(\sum(x)\Big)^2$) when these are in the range of $10^{8*2}$ and only differ on the scale of $10^0$ leaving a difference in the exponents of more than 15.

A better implementation could perhaps be to use a rewrite of the above formula and summing the deviations of each component from the mean of the vector and squaring this sum.

```{r}
myvar2 <- function(x){
    deviation <- x-mean(x)
    sum( deviation ^2 ) / (length(x) - 1)
}
varplot$MyVar2 = sapply(2:nx, function(i){ myvar2(x[1:i]) })
varplot$Diff2 <- varplot$MyVar2 - varplot$Var
 
```

```{r echo=FALSE}
ggplot(varplot, aes(x=Num_obs)) +
    geom_point(aes(y = Diff2, col = "Difference",  fill = "Difference", shape = "Difference")) +
    geom_point(aes(y = Var, col = "Var()", fill = "Var()", shape = "Var()")) +
    scale_fill_manual(name="",values = ldcol) +
    scale_colour_manual(name="",values = ddcol) +
    scale_shape_manual(name="",values = c(21,21)) +
    labs(title="Difference between built-in variance function and improved own implementation\n by number of observations used") +
    scale_x_log10() +
    theme(legend.position = "bottom")
```

Spot on...

# Linear algebra for solving equation systems

*Try and solve $\mathbf{X}^T \mathbf{X} \vec{\beta} = \mathbf{X}^T \bf{y}$ using the built-in `solve()` on both raw data and scaled data. Comment the result*

```{r}
tec <- read.csv("tecator.csv")
X <- as.matrix(cbind(1, tec[,-c(1,which(colnames(tec) =="Protein"))]))
y <- as.matrix(tec[,which(colnames(tec) =="Protein")])
#beta <- solve(t(X)%*%X,t(X)%*%y)
```

Didn't go too well... Apparently the determinant of  $\mathbf{X}^T \mathbf{X}$ is numerically equivalent to zero and the system cannot be solved. 

```{r}
kappa(t(X)%*%X)
```

...

```{r}
# Rebind intercept column since it will fail the scaling
sX <- cbind(1,scale(X[,-1]))
sbeta <- solve(t(sX)%*%sX,t(sX)%*%y)
knitr::kable(t(head(sbeta)),digits = 3)
```

